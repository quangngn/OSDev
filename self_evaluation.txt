CSC 395 - Advanced Operating Systems
Name: Quang Nguyen

Note: In this self-evaluation, I would also discuss some implementation decision and extra features of the kernel.

1. Input/Output:
* Score: 3.
* Note: 
The implementation meets the expection for kprintf() and kget_c() functions. The kprintf() function correctly interpret %c, %s, %d, %x, %p. The function also considers the following case:
- kprintf("Hi! %") prints "Hi! ".
- kprintf("%%) prints "%". This is how we print '%' character.
- kprintf("% ")(or any other unsupported formats )prints "<not supported>".

After being provided with term.h and term.c, I update term_write() function to allow printing with different colors. Thus, we have:
- kprintf() would print white on black text.
- kperror() similar to kprintf() but print red on black.
The set_mode() function in kprint.c is a quick functions to switch between different color mode. 

The kget_c() function use keyboard object to read input from the circular queue. It can process all typable characters, including tab, enter, backspace. It also correctly interprets holding Shift, Ctrl, Alt, and Caps Lock. The mechanism for this feature is as follows: 
- Upon receiving scan code for key down, a state variable (specific to each key) is set. For Shift, Ctr, and Alt, upon key up, this state variable is turn off (set to 0). For Caps Lock, the state variable is turn off upon reading key down scan code.
- Limitation: I haven't test when trying to hold down both Shift keys and then release 1 key. This case, the keyboard might set shift state variable = 0.

File: kernel/kprint.*, kernel/keyboard.*, kernel/term.*

2. Exceptions:
* Score: 3.
* Note:
The implementation correctly set up IDT for handling and printing message upon receiving an interrupt. The interrupts include 1 to 21, 0x21 for keyboard, 0x80 for syscall.

File: kernel/idt.*, kernel/pic.*

3. Virtual Memory:
* Score: 3. 
* Note:
The implementation include vm_map(), vm_unmap(), and vm_protect() function as expected. The setup functions create a free list structure in our free physical memory to help managing physical pages. 

If vm_map is called on a mapped address, it would act as vm_protect. This is important especially during switching between executable. The old CODE segment is mapped but not writable. Calling vm_map with writable would sufficiently handler the load segment for this case. 

For each level PML4, PDPT, PD, and PT, I have a separate struct definition. I admit, this is unnecessary and overengineering. It make the the code much longer because I cannot use loop. My initial impression is that I don't know whether I would need to set any specific fields for a certain pt level. Hence, I make a specific struct definition for each level just in case.

File: kernel/page.*

4. System Calls:
* Score 3.
* Note: 
The kernel implementation supports read, write, mmap, unmap, mprotect, exec, and exit system calls. All are callable from user mode. There are some notes for the implementation:

The read_handler() for read syscall has 3 extra arguments: bool incl_newln, bool echo_char, int64_t read_char_counter. This is a design decision to support better read function. 
- incl_newln: let caller decide whether to include newline character.
- echo_char: let caller decide whether to print the read characters to the terminal (in light green color).
- read_char_counter: this is the number of read characters in the buffer before the read_handler() is called. The syscall can use this as a hint to continue writing to buffer. This is decision to help implementing a dynamic getline.

The read_handler() can handle backspace on terminal and in buffer. I have modified the term_putchar() to allow backspace reduce cursor's row. With echo_char boolean being true, what you see is what you get. 

The write_handler() use white text for STD_OUT and red text for STD_ERR.

The exit_handler() calls the shell.

File: kernel/syscall.*

5. Loader:
* Score 3.
* Note: 
The implementation load and execute any executables as expected. 

Note that since we do not support multiple processes context switch, these processes share the same address space. As a result, I modified their linkers to give them different entry address. 

My approach is reading the module struct once, collecting each executable's information and organized into a linked list of exe_info_t node. We can view this as a simple in memory directory. This helps: 
- Simplify the load and unmap executable code. 
- Easy to identify the currently active executable.

At anytime, there is only one executable being executed. Upon switching between two executables, the old executable's memory is unmapped from the address space. 

File: kernel/executable.*, kernel/page.*, stdlib/process.*

6. Standard Library:
* Score: 3.
* Note:
The standard library implementation handles all the mentioned and more functions, including:
- string.h: strtok, strsep, strlen, strcpy, atoi, strpbrk, strcmp.
- stdio.h: read_syscall (a wrapper around the syscall invocation), write_syscall (a wrapper around the syscall invocation), printf, getline, perror.
- mem.h: mmap (this one requires a new system call), malloc, memcpy, memset.
- process.h: exec, exit.
- assert.h: assert (help with testing string functions).

Note that, getline is dynamically malloc. It shows input live in the terminal. What you see is what you get. The backspace is handle as expected.

The init program includes a test_stdlib.h to test for string and stdio functions.

File: stdlib folder.

7. User Mode:
* Score: 3.
* Note: 
The implementation successfully sets up the user mode and passes the test for reading kernel only permission memory. All loaded executables are executed as expected.

File: kernel/gdt.*, kernel/*usermode_entry.h, * kernel/executable.c

8. Processes:
* Score: 3.
* Note: 
The kernel provides run_exe() and exec() syscall to be able to run process from both kernel and user mode. 

Upon exiting, the program will call shell program.

File: kernel/syscall.*, stdlib/process.*

9. Shell:
* Score 3.
* Note:
My implementation is a bit different. I have 2 executables: init and shell. From shell, we can call init (type init) or shell itself.

We can easily add more executables, simply like how we add init. shell will be able to call these executables without modifying kernel code.

Invalid command will yield an error message. The command can contain white character at such as space at the beginning. The command is case sensitive. 

10. Code quality:
* Score 2.
* Note:
I use Google style guide for the code and documented carefully. The files are organized by types. 

However, I still have some problems: 
- Naming of some variables are verbose. 
- Some functions are very and messy. 
- Some code logic is complex and overcomplicated. 







