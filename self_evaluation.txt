CSC 395 - Advanced Operating Systems
Name: Quang Nguyen

Note: In this self-evaluation, I would also discuss some implementation decisions and extra features of the kernel.

1. Input/Output:
* Score: 3.
* Note: 
The implementation meets the expection for kprintf() and kget_c() functions. The kprintf() function correctly interpret %c, %s, %d, %x, %p. The function also considers the following case:
- kprintf("Hi! %") prints "Hi! ".
- kprintf("%%) prints "%". This is how we print '%' character.
- kprintf("% ")(or any other unsupported formats )prints "<not supported>".

After being provided with term.h and term.c, I update term_write() function to allow printing with different colors. Thus, we have:
- kprintf() would print white on black text.
- kperror() similar to kprintf() but print red on black.
The set_mode() function in kprint.c is a quick function to switch between different color modes. 

The kget_c() function uses the keyboard object to read input from the circular queue. It can process all typable characters, including tab, enter, and backspace. It also correctly interprets holding Shift, Ctrl, Alt, and Caps Lock. The mechanism for this feature is as follows: 
- Upon receiving a scan code for key down, a state variable (specific to each key) is set. For Shift, Ctr, and Alt, upon key up, this state variable is turn off (set to 0). For Caps Lock, the state variable is toggled upon reading next key down scan code.
- Limitation: I haven't test when trying to hold down both Shift keys and then release 1 key. This case, the keyboard might set shift state variable = 0.

File: kernel/kprint.*, kernel/keyboard.*, kernel/term.*

2. Exceptions:
* Score: 3.
* Note:
The implementation correctly set up IDT for handling and printing message upon receiving an interrupt. The interrupts include 1 to 21, 0x21 for keyboard, 0x80 for syscall.

File: kernel/idt.*, kernel/pic.*

3. Virtual Memory:
* Score: 3. 
* Note:
The implementation include vm_map(), vm_unmap(), and vm_protect() function as expected. The setup functions create a free list structure in our free physical memory to help manage physical pages. 

If vm_map is called on a mapped address, it would act as vm_protect. This is important, especially during switching between executables. The old CODE segment is mapped but not writable. Calling vm_map with writable would sufficiently handle the load segment for this case. 

For each level PML4, PDPT, PD, and PT, I have a separate struct definition. I admit that this is unnecessary and overengineering. It makes the code much longer because I cannot use loop. My initial impression is that I don't know whether I would need to set any specific fields for a certain pt level. Hence, I make a specific struct definition for each level just in case.

File: kernel/page.*

4. System Calls:
* Score 3.
* Note: 
The kernel implementation supports read, write, mmap, unmap, mprotect, exec, and exit system calls. All are callable from user mode. There are some notes for the implementation:

The read_handler() for read syscall has 3 extra arguments: bool incl_newln, bool echo_char, int64_t read_char_counter. This is a design decision to support a better read function. 
- incl_newln: let the caller decide whether to include newline character.
- echo_char: let the caller decide whether to print the read characters to the terminal (in light green color).
- read_char_counter: this is the number of read characters in the buffer before the read_handler() is called. The syscall can use this as a hint to continue writing to buffer. This decision helps implementing a dynamic getline.

The read_handler() can handle backspace on the terminal and in the buffer. I have modified the term_putchar() to allow backspace to reduce the cursor's row. With echo_char boolean being true, what you see is what you get. 

The write_handler() uses white text for STD_OUT and red text for STD_ERR.

The exit_handler() calls the shell.

File: kernel/syscall.*

5. Loader:
* Score 3.
* Note: 
The implementation loads and executes any executables as expected. 

Note that since we do not support multiple processes context switch, these processes share the same address space. As a result, I modified their linkers to give them different entry addresses. 

My approach is reading the module struct once, collecting each executable's information, and organized into a linked list of exe_info_t nodes. We can view this as a simple in-memory directory. This helps: 
- Simplify the load and unmap executable code. 
- Easy to identify the currently active executable.

At any time, there is only one executable being executed. Upon switching between two executables, the old executable's memory is unmapped from the address space. 

File: kernel/executable.*, kernel/page.*, stdlib/process.*

6. Standard Library:
* Score: 3.
* Note:
The standard library implementation handles all the mentioned and more functions, including:
- string.h: strtok, strsep, strlen, strcpy, atoi, strpbrk, strcmp.
- stdio.h: read_syscall (a wrapper around the syscall invocation), write_syscall (a wrapper around the syscall invocation), printf, getline, perror.
- mem.h: mmap (this one requires a new system call), malloc, memcpy, memset.
- process.h: exec, exit.
- assert.h: assert (help with testing string functions).

Note that, getline is dynamically malloc. It shows input live in the terminal. What you see is what you get. The backspace is handle as expected. 

The implementation of getline does not call getc() to fill the buffer one character at a time. Instead, it calls sys_read() on the entire buffer. If the buffer is full, we reallocated the buffer to a bigger size. This time sys_read would use the read_char_counter argument to continue reading to buffer. 

The reason for this implementation is that it is easier for getline to process the backspace behavior in both terminal and buffer. I acknowledge that this makes sys_read() call more complicated. To be honest, I still wonder whether I should put the backspace handler in the syscall's read_handler() or getline().

The init program includes a test_stdlib.h to test for string and stdio functions.

File: stdlib folder.

7. User Mode:
* Score: 3.
* Note: 
The implementation successfully sets up the user mode and passes the test for reading kernel-only permission memory. All loaded executables are executed as expected.

File: kernel/gdt.*, kernel/*usermode_entry.h, * kernel/executable.c

8. Processes:
* Score: 3.
* Note: 
The kernel provides run_exe() and exec() syscall to be able to run processes from both kernel and user mode. 

Upon exiting, the program will call the shell program.

File: kernel/syscall.*, stdlib/process.*

9. Shell:
* Score 3.
* Note:
My implementation is a bit different. I have 2 executables: init and shell. From shell, we can call init (type init) or shell itself.

We can easily add more executables, simply like how we add init. shell will be able to call these executables without modifying kernel code.

The invalid command will yield an error message. The command can contain white characters (such as space) at the beginning. The command is case-sensitive. 

10. Code quality:
* Score 3.
* Note:
I use Google style guide for the code and document carefully. The files are organized by types. 

However, I still have some problems: 
- Naming of some variables are verbose. 
- Some functions are long and messy to read. 
- Some code logic is complex and overcomplicated. 







